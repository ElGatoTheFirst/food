<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Food Classifier</title>

  <style>
    :root{
      --bg:#0b1220;
      --card:#101a30;
      --card2:#0e1628;
      --text:#e9eefc;
      --muted:#a6b0cf;
      --line:rgba(255,255,255,.10);
      --accent:#7c5cff;
      --good:#26d07c;
      --warn:#ffcf5a;
      --bad:#ff5b6a;
      --shadow: 0 12px 32px rgba(0,0,0,.35);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(124,92,255,.22), transparent 55%),
                  radial-gradient(900px 500px at 80% 20%, rgba(38,208,124,.14), transparent 55%),
                  var(--bg);
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 18px 14px 26px;
      padding-bottom: calc(26px + env(safe-area-inset-bottom));
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin: 6px 0 14px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title h1{
      margin:0;
      font-size: 20px;
      letter-spacing:.2px;
      line-height:1.1;
    }
    .title p{
      margin:0;
      font-size: 13px;
      color: var(--muted);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap;
    }
    .dot{
      width:9px;height:9px;border-radius:999px;background:var(--warn);
      box-shadow: 0 0 0 4px rgba(255,207,90,.14);
    }
    .dot.ok{ background: var(--good); box-shadow: 0 0 0 4px rgba(38,208,124,.14); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 0 4px rgba(255,91,106,.14); }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }
    @media (max-width: 860px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      border-bottom: 1px solid var(--line);
      background: rgba(0,0,0,.14);
    }
    .card .head h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .card .body{
      padding: 12px;
    }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    button{
      appearance:none;
      border:0;
      cursor:pointer;
      border-radius: 14px;
      padding: 11px 12px;
      font-weight: 650;
      font-size: 14px;
      color: var(--text);
      background: rgba(255,255,255,.08);
      border: 1px solid var(--line);
      transition: transform .05s ease, background .2s ease;
    }
    button:active{ transform: scale(.98); }
    button.primary{
      background: linear-gradient(180deg, rgba(124,92,255,.95), rgba(124,92,255,.75));
      border: 1px solid rgba(124,92,255,.55);
    }
    button.danger{
      background: rgba(255,91,106,.12);
      border: 1px solid rgba(255,91,106,.35);
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    .seg{
      display:inline-flex;
      border:1px solid var(--line);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(255,255,255,.04);
    }
    .seg button{
      border:0;
      border-right:1px solid var(--line);
      border-radius:0;
      padding: 10px 12px;
      background: transparent;
      color: var(--muted);
      font-weight: 650;
      font-size: 13px;
    }
    .seg button:last-child{ border-right:0; }
    .seg button.active{
      background: rgba(124,92,255,.22);
      color: var(--text);
    }

    .videoShell{
      position:relative;
      border-radius: 16px;
      overflow:hidden;
      background: #050816;
      border:1px solid rgba(255,255,255,.10);
    }
    video{
      width:100%;
      height:auto;
      display:block;
      transform: scaleX(-1); /* default mirrored (front cam) */
    }
    .videoShell.back video{ transform:none; } /* back cam not mirrored */

    .overlay{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(800px 400px at 50% 0%, rgba(124,92,255,.18), transparent 55%),
        linear-gradient(180deg, rgba(0,0,0,.30), transparent 30%, transparent 70%, rgba(0,0,0,.25));
    }
    .scanBox{
      position:absolute;
      left: 12%;
      top: 18%;
      width: 76%;
      height: 64%;
      border-radius: 18px;
      border: 2px solid rgba(255,255,255,.20);
      box-shadow: 0 0 0 999px rgba(0,0,0,.12) inset;
    }
    .scanLine{
      position:absolute;
      left: 12%;
      width: 76%;
      height: 2px;
      top: 20%;
      background: linear-gradient(90deg, transparent, rgba(124,92,255,.95), transparent);
      filter: drop-shadow(0 0 10px rgba(124,92,255,.55));
      animation: scan 2.2s linear infinite;
      opacity:.9;
    }
    @keyframes scan{
      0%{ transform: translateY(0); opacity:.2; }
      10%{ opacity:.9; }
      50%{ opacity:.9; }
      90%{ opacity:.9; }
      100%{ transform: translateY(260px); opacity:.2; }
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
    }

    .live{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .big{
      font-size: 18px;
      font-weight: 750;
      letter-spacing:.2px;
      margin:0;
    }
    .small{
      margin:0;
      color: var(--muted);
      font-size: 12px;
    }

    .klist{
      margin: 10px 0 0;
      padding: 0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .kitem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .kitem .lbl{
      font-weight: 650;
      font-size: 13px;
    }
    .kitem .prob{
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      font-size: 13px;
    }

    .verdict{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding: 12px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
    }
    .verdictTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap;
    }
    .badge strong{ color: var(--text); font-weight: 750; }
    .muted{ color: var(--muted); }

    .history{
      margin: 10px 0 0;
      padding: 0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .history li{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
    }
    .history .hlabel{
      font-weight: 650;
      font-size: 13px;
    }
    .history .hmeta{
      color: var(--muted);
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }

    .err{
      margin-top: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,91,106,.10);
      border:1px solid rgba(255,91,106,.30);
      color: #ffd7db;
      font-size: 12px;
      display:none;
      white-space:pre-wrap;
      word-break:break-word;
    }

    .footerHint{
      margin-top: 10px;
      color: rgba(255,255,255,.55);
      font-size: 11.5px;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <header>
      <div class="title">
        <h1>Food Classifier</h1>
        <p>1 frame/sec → 1 verdict/min (most frequent label wins)</p>
      </div>
      <div class="pill" id="statusPill">
        <span class="dot" id="statusDot"></span>
        <span id="statusText">Ready</span>
      </div>
    </header>

    <div class="grid">

      <!-- LEFT: CAMERA -->
      <section class="card">
        <div class="head">
          <h2>Camera</h2>
          <div class="badge"><strong id="countdown">01:00</strong>&nbsp;<span class="muted">to verdict</span></div>
        </div>
        <div class="body">
          <div class="videoShell" id="videoShell">
            <!-- iPhone SAFARI: playsinline + muted helps -->
            <video
              id="preview"
              autoplay
              muted
              playsinline
              webkit-playsinline
            ></video>
            <div class="overlay"></div>
            <div class="scanBox"></div>
            <div class="scanLine"></div>
          </div>

          <div class="row">
            <div class="controls">
              <button class="primary" id="btnStart">Start</button>
              <button class="danger" id="btnStop" disabled>Stop</button>

              <div class="seg" role="group" aria-label="Camera facing mode">
                <button id="btnBack" type="button">Back</button>
                <button id="btnFront" type="button" class="active">Front</button>
              </div>
            </div>

            <div class="pill">
              <span class="muted">Frames/min:</span>
              <strong id="framesThisMinute">0</strong>
            </div>
          </div>

          <div class="err" id="errBox"></div>

          <div class="footerHint">
            iPhone tip: If it asks, allow camera. If you opened inside an in-app browser, try Safari.
          </div>
        </div>
      </section>

      <!-- RIGHT: RESULTS -->
      <section class="card">
        <div class="head">
          <h2>Results</h2>
          <div class="badge" id="minuteBadge"><strong>Running</strong></div>
        </div>
        <div class="body">

          <div class="verdict">
            <div class="verdictTop">
              <div class="live">
                <p class="small">Minute verdict</p>
                <p class="big" id="minuteLabel">—</p>
              </div>
              <div class="live" style="text-align:right">
                <p class="small">Minute meta</p>
                <p class="small" id="minuteMeta">Waiting…</p>
              </div>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="verdict">
            <div class="verdictTop">
              <div class="live">
                <p class="small">Live (last frame)</p>
                <p class="big" id="liveLabel">—</p>
              </div>
              <div class="live" style="text-align:right">
                <p class="small">Confidence</p>
                <p class="big" id="liveConf">—</p>
              </div>
            </div>

            <ul class="klist" id="topList"></ul>
          </div>

          <div style="height:10px"></div>

          <p class="small" style="margin:0 0 6px;">Recent minute verdicts</p>
          <ul class="history" id="historyList"></ul>

        </div>
      </section>

    </div>
  </div>

  <script>
    // ✅ Use your working endpoint
    window.API_BASE = "https://elgatito1-food-classifier.hf.space";

    // Settings
    const TOP_K = 3;
    const FPS_INTERVAL_MS = 1000;      // 1 frame/sec
    const MINUTE_MS = 60_000;

    // DOM
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const errBox = document.getElementById("errBox");

    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnBack = document.getElementById("btnBack");
    const btnFront = document.getElementById("btnFront");

    const videoShell = document.getElementById("videoShell");
    const video = document.getElementById("preview");
    const countdownEl = document.getElementById("countdown");

    const framesThisMinuteEl = document.getElementById("framesThisMinute");
    const liveLabel = document.getElementById("liveLabel");
    const liveConf = document.getElementById("liveConf");
    const topList = document.getElementById("topList");

    const minuteLabel = document.getElementById("minuteLabel");
    const minuteMeta = document.getElementById("minuteMeta");
    const minuteBadge = document.getElementById("minuteBadge");
    const historyList = document.getElementById("historyList");

    // State
    let stream = null;
    let captureTimer = null;
    let countdownTimer = null;
    let inFlight = false;

    let facing = "user"; // "user" (front) or "environment" (back)

    // Minute aggregation
    let minuteStart = null;
    let framesThisMinute = 0;
    let frameCounts = new Map(); // label -> count
    let confSums = new Map();    // label -> sum(conf)

    // Canvas
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: false });

    // ---------- helpers ----------
    function setStatus(kind, text){
      statusText.textContent = text;
      statusDot.classList.remove("ok","bad");
      if (kind === "ok") statusDot.classList.add("ok");
      else if (kind === "bad") statusDot.classList.add("bad");
    }

    function showError(msg){
      errBox.style.display = "block";
      errBox.textContent = msg;
      setStatus("bad", "Error");
    }

    function clearError(){
      errBox.style.display = "none";
      errBox.textContent = "";
    }

    function fmtPct(x){
      if (typeof x !== "number" || !isFinite(x)) return "—";
      return (x * 100).toFixed(1) + "%";
    }

    function fmtMMSS(ms){
      const s = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2,"0");
      const ss = String(s % 60).padStart(2,"0");
      return `${mm}:${ss}`;
    }

    function nowTime(){
      const d = new Date();
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      const ss = String(d.getSeconds()).padStart(2,"0");
      return `${hh}:${mm}:${ss}`;
    }

    function setFacing(mode){
      facing = mode;
      btnFront.classList.toggle("active", mode === "user");
      btnBack.classList.toggle("active", mode === "environment");
      videoShell.classList.toggle("back", mode === "environment");
    }

    // iPhone-safe: wait until the video has actual dimensions
    async function waitForVideoReady(timeoutMs = 6000){
      const start = Date.now();
      while (Date.now() - start < timeoutMs){
        if (video.readyState >= 2 && video.videoWidth > 0 && video.videoHeight > 0){
          return true;
        }
        await new Promise(r => setTimeout(r, 80));
      }
      return false;
    }

    // ---------- camera ----------
    async function startCamera(){
      clearError();
      setStatus("", "Requesting camera…");

      // Must be called from a user gesture (button click) on iOS.
      // Try strict constraints first, then fallback.
      const base = {
        audio: false,
        video: {
          facingMode: { ideal: facing },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      try{
        stream = await navigator.mediaDevices.getUserMedia(base);
      }catch(e1){
        try{
          stream = await navigator.mediaDevices.getUserMedia({ audio:false, video:true });
        }catch(e2){
          showError(
            "Camera failed.\n\n" +
            "Common iPhone fixes:\n" +
            "• Use Safari (not Instagram/TikTok browser)\n" +
            "• Settings → Safari → Camera → Allow\n" +
            "• Refresh and try again\n\n" +
            "Details: " + (e2?.message || e2)
          );
          throw e2;
        }
      }

      video.srcObject = stream;

      // Important for iOS: playsinline + muted already set in HTML
      // Now play() inside user action context
      try{
        await video.play();
      }catch(_){ /* ignore */ }

      const ok = await waitForVideoReady();
      if (!ok){
        showError("Camera started but video not ready. Try again or switch camera.");
        throw new Error("video not ready");
      }

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      setStatus("ok", "Running");
      btnStart.disabled = true;
      btnStop.disabled = false;

      minuteStart = Date.now();
      resetMinuteCountersOnly();
      startLoops();
    }

    function stopCamera(){
      stopLoops();

      if (stream){
        const tracks = stream.getTracks();
        tracks.forEach(t => t.stop());
      }
      stream = null;
      video.srcObject = null;

      btnStart.disabled = false;
      btnStop.disabled = true;

      setStatus("", "Stopped");
    }

    // ---------- loops ----------
    function startLoops(){
      stopLoops();

      // countdown refresh (smooth)
      countdownTimer = setInterval(updateCountdown, 250);

      // capture loop (1fps)
      captureTimer = setInterval(captureOnce, FPS_INTERVAL_MS);

      updateCountdown();
    }

    function stopLoops(){
      if (captureTimer) clearInterval(captureTimer);
      if (countdownTimer) clearInterval(countdownTimer);
      captureTimer = null;
      countdownTimer = null;
      inFlight = false;
    }

    function updateCountdown(){
      if (!minuteStart){
        countdownEl.textContent = "01:00";
        return;
      }
      const elapsed = Date.now() - minuteStart;
      const remaining = MINUTE_MS - elapsed;
      countdownEl.textContent = fmtMMSS(remaining);

      // finalize if time passed
      if (elapsed >= MINUTE_MS){
        finalizeMinuteVerdict();
      }
    }

    // Only reset counters — do NOT clear the displayed verdict
    function resetMinuteCountersOnly(){
      frameCounts = new Map();
      confSums = new Map();
      framesThisMinute = 0;
      framesThisMinuteEl.textContent = "0";
      minuteMeta.textContent = "Collecting…";
      minuteBadge.innerHTML = "<strong>Running</strong>";
    }

    function finalizeMinuteVerdict(){
      if (!minuteStart) return;

      // If no frames collected, keep old verdict visible
      if (framesThisMinute === 0 || frameCounts.size === 0){
        minuteMeta.textContent = "No frames captured in last minute.";
        minuteStart = Date.now();
        resetMinuteCountersOnly();
        return;
      }

      let bestLabel = null;
      let bestCount = -1;
      let bestAvg = -1;

      for (const [label, count] of frameCounts.entries()){
        const sum = confSums.get(label) || 0;
        const avg = sum / Math.max(1, count);
        if (count > bestCount || (count === bestCount && avg > bestAvg)){
          bestLabel = label;
          bestCount = count;
          bestAvg = avg;
        }
      }

      // Update minute verdict and KEEP it visible
      minuteLabel.textContent = bestLabel;
      minuteMeta.textContent = `${bestCount}/${framesThisMinute} frames • avg ${fmtPct(bestAvg)} • ${nowTime()}`;
      minuteBadge.innerHTML = "<strong>VERDICT</strong>";

      // Add to history
      const li = document.createElement("li");
      const left = document.createElement("div");
      const right = document.createElement("div");
      left.className = "hlabel";
      right.className = "hmeta";
      left.textContent = bestLabel;
      right.textContent = `${bestCount}/${framesThisMinute} • ${nowTime()}`;
      li.appendChild(left);
      li.appendChild(right);
      historyList.insertBefore(li, historyList.firstChild);

      while (historyList.children.length > 6){
        historyList.removeChild(historyList.lastChild);
      }

      // Start next minute window
      minuteStart = Date.now();
      resetMinuteCountersOnly();
    }

    // ---------- API ----------
    async function sendFrameToApi(blob){
      // Strategy A: /predict multipart (common)
      const urlA = `${window.API_BASE}/predict?top_k=${TOP_K}`;
      try{
        const fd = new FormData();
        fd.append("file", blob, "frame.jpg");
        const res = await fetch(urlA, { method:"POST", body: fd });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      }catch(_){
        // Strategy B: /predict_base64 JSON (fallback)
        const b64 = await blobToBase64(blob);
        const urlB = `${window.API_BASE}/predict_base64?top_k=${TOP_K}`;
        const res = await fetch(urlB, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({ image_base64: b64 })
        });
        if (!res.ok){
          const text = await res.text().catch(()=> "");
          throw new Error(`API failed: ${res.status}\n${text.slice(0,300)}`);
        }
        return await res.json();
      }
    }

    function blobToBase64(blob){
      return new Promise((resolve,reject)=>{
        const r = new FileReader();
        r.onload = () => {
          const dataUrl = String(r.result || "");
          resolve(dataUrl.split(",")[1] || "");
        };
        r.onerror = reject;
        r.readAsDataURL(blob);
      });
    }

    // ---------- capture ----------
    async function captureOnce(){
      if (!stream) return;
      if (inFlight) return;

      // iOS: sometimes readyState drops; skip safely
      if (video.readyState < 2 || video.videoWidth === 0 || video.videoHeight === 0) return;

      inFlight = true;

      try{
        // Keep canvas in sync (just in case iOS changes sizes)
        if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight){
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
        }

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const blob = await new Promise((resolve)=>{
          // iOS supports toBlob, but keep safe
          if (canvas.toBlob){
            canvas.toBlob((b)=> resolve(b), "image/jpeg", 0.80);
          }else{
            const dataUrl = canvas.toDataURL("image/jpeg", 0.80);
            fetch(dataUrl).then(r => r.blob()).then(resolve);
          }
        });

        if (!blob) throw new Error("Failed to encode frame.");

        const data = await sendFrameToApi(blob);
        renderResult(data);

        // Aggregate per-minute
        const label = data?.predicted_label;
        const conf = Number(data?.confidence);

        if (label){
          framesThisMinute += 1;
          framesThisMinuteEl.textContent = String(framesThisMinute);

          frameCounts.set(label, (frameCounts.get(label) || 0) + 1);
          if (isFinite(conf)){
            confSums.set(label, (confSums.get(label) || 0) + conf);
          }
        }

        // if minute passed, finalize
        if (minuteStart && (Date.now() - minuteStart) >= MINUTE_MS){
          finalizeMinuteVerdict();
        }

      }catch(e){
        showError("Capture/API error:\n" + (e?.message || e));
        // keep running, but avoid spamming the user
      }finally{
        inFlight = false;
      }
    }

    function renderResult(data){
      const label = data?.predicted_label ?? "—";
      const conf = Number(data?.confidence);

      liveLabel.textContent = label;
      liveConf.textContent = isFinite(conf) ? fmtPct(conf) : "—";

      // top_k list
      topList.innerHTML = "";
      const items = Array.isArray(data?.top_k) ? data.top_k : [];

      for (let i=0; i<items.length; i++){
        const it = items[i] || {};
        const lbl = it.label ?? it.class ?? "—";
        const prob = Number(it.prob);

        const li = document.createElement("li");
        li.className = "kitem";

        const left = document.createElement("div");
        left.className = "lbl";
        left.textContent = `${i+1}. ${lbl}`;

        const right = document.createElement("div");
        right.className = "prob";
        right.textContent = isFinite(prob) ? fmtPct(prob) : "—";

        li.appendChild(left);
        li.appendChild(right);
        topList.appendChild(li);
      }
    }

    // ---------- events ----------
    btnFront.addEventListener("click", async ()=>{
      setFacing("user");
      if (stream){
        stopCamera();
        // iPhone: must restart with a tap; this click counts as a gesture
        try{ await startCamera(); }catch(_){}
      }
    });

    btnBack.addEventListener("click", async ()=>{
      setFacing("environment");
      if (stream){
        stopCamera();
        try{ await startCamera(); }catch(_){}
      }
    });

    btnStart.addEventListener("click", async ()=>{
      // iPhone requires this to be directly triggered by the tap.
      try{
        clearError();
        await startCamera();
      }catch(_){}
    });

    btnStop.addEventListener("click", ()=>{
      stopCamera();
    });

    // Init UI
    setFacing("user");
    setStatus("", "Ready");
    minuteMeta.textContent = "Waiting…";
    updateCountdown();
  </script>
</body>
</html>
